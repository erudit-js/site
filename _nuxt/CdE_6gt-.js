var p=Object.defineProperty;var x=(e,a,r)=>a in e?p(e,a,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[a]=r;var t=(e,a,r)=>x(e,typeof a!="symbol"?a+"":a,r);import{aW as f,aX as y,aY as M,aZ as i}from"./CAkvs08M.js";import{B as m,r as u,g as o,I as P,a as R}from"./DJEup2hA.js";const l=e=>{const a=e[1],r=e[0].indexOf(a);return[r,r+a.length]};class $ extends y{constructor(){super(...arguments);t(this,"objectRegexp",/^@math$([\S\s]+)/m);t(this,"dollarRegexp",/^\$\$([\S\s]+?)\$\$$/m);t(this,"range")}canParse(r){const s=(h,d)=>{const n=h.exec(d);return n&&n.index===0?n:!1};let c=s(this.objectRegexp,r)||s(this.dollarRegexp,r);return c?(this.range=l(c),!0):!1}async createParseData(r){return{src:r,range:this.range}}}class S extends M{constructor(){super(...arguments);t(this,"regexp",/\$([^\$]+)\$/g)}async parseDataFromRegexp(r){return{src:r[0],range:l(r)}}}class g extends f{async stringifyElement(){const{parseData:a}=this.payload();return a.src}}const k=i({Node:m,Parsers:[$],Stringifier:g,async createPreRenderData(e){return u(o(e))}}),B=i({Node:P,Parsers:[S],Stringifier:g,async createPreRenderData(e){return R(o(e))}});export{k as blockMathTranspiler,B as inlineMathTranspiler};
